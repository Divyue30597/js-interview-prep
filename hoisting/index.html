<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <p id="demo-1"></p>
    <p id="demo-2"></p>
    <p id="demo-3"></p>
    <p id="demo-4"></p>
    <p id="demo-5"></p>
    <p id="demo-6"></p>

    <script>
      // Test case 1: Initialized x first and then initialized y later.
      var x = 5; // Initialize x
      elem = document.getElementById("demo-1"); // Find an element
      elem.innerHTML = "x is " + x + " and y is " + y; // Display x and y
      var y = 7; // Initialize y
      // OP : x is 5 and y is undefined

      // Test Case 2: Initialized q first and declared w, and then later w is initialized.
      var q = 5; // Initialize x
      var w; // declared w
      elem = document.getElementById("demo-2"); // Find an element
      elem.innerHTML = "q is " + q + " and w is " + w; // Display x and y
      w = 7; // Initialized w
      // OP: q is 5 and w is undefined

      // Test case 3: Intializing e and r at the top
      var e = 5; // Initialize x
      var r = 7; // Initialize w
      elem = document.getElementById("demo-3"); // Find an element
      elem.innerHTML = "e is " + e + " and r is " + r; // Display x and y
      // OP: e is 5 and r is 7

      // Test case 4: Intializing e and r at the top
      elem = document.getElementById("demo-4"); // Find an element
      elem.innerHTML = "t is " + t + " and u is " + u; // Display x and y
      var t = 5; // Initialize t
      var u = 7; // Initialize y
      // OP: t is undefined and u is undefined

      // Test case 5: Declaring i and o at the top
      var i; // Initialize t
      var o; // Initialize y
      elem = document.getElementById("demo-5"); // Find an element
      elem.innerHTML = "i is " + i + " and o is " + o; // Display x and y
      i = 5; // Initialize t
      o = 7; // Initialize y
      // OP: i is undefined and o is undefined

      // Test case 5: Declaring i and o at the top
      p = 5; // assign to p
      a = 7; // assign to a
      elem = document.getElementById("demo-6"); // Find an element
      elem.innerHTML = "p is " + p + " and a is " + a; // Display x and y
      var p; // Initialize t
      var a; // Initialize y
      // OP: p is 5 and a is 7

      // Using let and const
      // This will throw referenceError: Cannot access 'carName' before initialization
      // carName = "Volvo";
      // let carName;

      // This will throw error Missing initializer in const declaration
      // carName2 = "Volvo"
      // const carName2;

      // Hoisting and TDZ in Practice
      // Variables
      console.log(me); // undefined Why?? -> variables declared with var are actually hoisted, but they are hoisted to the value of undefined.
      // let job = "teacher";
      // console.log(job); // Reference Error -> Why?? Because the job variable is still in temporal dead zone, the temporal dead zone of a variable declared with a let or const, starts from the beginning of the current scope and so that's basically here, so in this case, it's the global scope. So from the beginning of the scope until the point of the code where it is defined and so here.
      // console.log(year);
      var me = "Jonas";
      let job = "teacher";
      const year = 1991;

      // Functions
      console.log(addDecl(2, 3));
      // console.log(addExpr(2, 3)); We get the error here
      // Because the function is now a const variable and so now the addExpr (74) is in the temporal dead zone.
      // Here you can see this will return is undefined.
      console.log(addArrow);
      // Any variable declared with var will be hoisted and set to undefined.
      // Here (67) we are trying to call undefined. We are doing the same as undefined(2, 3) in console and get the same error.
      // console.log(addArrow(2, 3)); // addArrow is not a function
      function addDecl(a, b) {
        return a + b;
      }
      // We are simply assigning a function value to this variable. And since the variable was assigned with const it is now in a temporal dead zone.
      const addExpr = function (a, b) {
        return a + b;
      };
      var addArrow = (a, b) => a + b;
      // Example
      // console.log(undefined);
      // It is happening because of hoisting because numProducts value is not 10 but undefined. Since undefined is a falsy value. And the below block will run and thus deleteShoppingCart() function is called. Use const and let all the time and not to use var
      if (!numProducts) deleteShoppingCart();
      var numProducts = 10;
      function deleteShoppingCart() {
        console.log("All products deleted!");
      }
      // Variables declared with let and const donot create properties on the window object.
      var x = 1;
      let d = 2;
      const z = 3;
      console.log(x === window.x);
      console.log(d === window.d);
      console.log(z === window.z);
    </script>
  </body>
</html>
